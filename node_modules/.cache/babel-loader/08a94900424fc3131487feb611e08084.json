{"ast":null,"code":"\"use client\";\n\nimport toArray from \"rc-util/es/Children/toArray\";\nimport useIsomorphicLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\n\nfunction cuttable(node) {\n  const type = typeof node;\n  return type === 'string' || type === 'number';\n}\n\nfunction getNodesLen(nodeList) {\n  let totalLen = 0;\n  nodeList.forEach(node => {\n    if (cuttable(node)) {\n      totalLen += String(node).length;\n    } else {\n      totalLen += 1;\n    }\n  });\n  return totalLen;\n}\n\nfunction sliceNodes(nodeList, len) {\n  let currLen = 0;\n  const currentNodeList = [];\n\n  for (let i = 0; i < nodeList.length; i += 1) {\n    // Match to return\n    if (currLen === len) {\n      return currentNodeList;\n    }\n\n    const node = nodeList[i];\n    const canCut = cuttable(node);\n    const nodeLen = canCut ? String(node).length : 1;\n    const nextLen = currLen + nodeLen; // Exceed but current not which means we need cut this\n    // This will not happen on validate ReactElement\n\n    if (nextLen > len) {\n      const restLen = len - currLen;\n      currentNodeList.push(String(node).slice(0, restLen));\n      return currentNodeList;\n    }\n\n    currentNodeList.push(node);\n    currLen = nextLen;\n  }\n\n  return nodeList;\n}\n\nconst NONE = 0;\nconst PREPARE = 1;\nconst WALKING = 2;\nconst DONE_WITH_ELLIPSIS = 3;\nconst DONE_WITHOUT_ELLIPSIS = 4;\n\nconst Ellipsis = _ref => {\n  let {\n    enabledMeasure,\n    children,\n    text,\n    width,\n    fontSize,\n    rows,\n    onEllipsis\n  } = _ref;\n  const [[startLen, midLen, endLen], setCutLength] = React.useState([0, 0, 0]); // record last done with ellipsis width\n\n  const [lastLen, setLastLen] = React.useState(0);\n  const [walkingState, setWalkingState] = React.useState(NONE);\n  const [singleRowHeight, setSingleRowHeight] = React.useState(0);\n  const singleRowRef = React.useRef(null);\n  const midRowRef = React.useRef(null);\n  const nodeList = React.useMemo(() => toArray(text), [text]);\n  const totalLen = React.useMemo(() => getNodesLen(nodeList), [nodeList]);\n  const mergedChildren = React.useMemo(() => {\n    if (!enabledMeasure || walkingState !== DONE_WITH_ELLIPSIS) {\n      // if has lastLen, use it as temporary width to avoid lots of text to squeeze space.\n      if (lastLen && walkingState !== DONE_WITHOUT_ELLIPSIS && enabledMeasure) return children(sliceNodes(nodeList, lastLen), lastLen < totalLen);\n      return children(nodeList, false);\n    }\n\n    return children(sliceNodes(nodeList, midLen), midLen < totalLen);\n  }, [enabledMeasure, walkingState, children, nodeList, midLen, totalLen]); // ======================== Walk ========================\n\n  useIsomorphicLayoutEffect(() => {\n    if (enabledMeasure && width && fontSize && totalLen) {\n      setWalkingState(PREPARE);\n      setCutLength([0, Math.ceil(totalLen / 2), totalLen]);\n    }\n  }, [enabledMeasure, width, fontSize, text, totalLen, rows]);\n  useIsomorphicLayoutEffect(() => {\n    var _a;\n\n    if (walkingState === PREPARE) {\n      setSingleRowHeight(((_a = singleRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0);\n    }\n  }, [walkingState]);\n  useIsomorphicLayoutEffect(() => {\n    var _a, _b;\n\n    if (singleRowHeight) {\n      if (walkingState === PREPARE) {\n        // Ignore if position is enough\n        const midHeight = ((_a = midRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;\n        const maxHeight = rows * singleRowHeight;\n\n        if (midHeight <= maxHeight) {\n          setWalkingState(DONE_WITHOUT_ELLIPSIS);\n          onEllipsis(false);\n        } else {\n          setWalkingState(WALKING);\n        }\n      } else if (walkingState === WALKING) {\n        if (startLen !== endLen) {\n          const midHeight = ((_b = midRowRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;\n          const maxHeight = rows * singleRowHeight;\n          let nextStartLen = startLen;\n          let nextEndLen = endLen; // We reach the last round\n\n          if (startLen === endLen - 1) {\n            nextEndLen = startLen;\n          } else if (midHeight <= maxHeight) {\n            nextStartLen = midLen;\n          } else {\n            nextEndLen = midLen;\n          }\n\n          const nextMidLen = Math.ceil((nextStartLen + nextEndLen) / 2);\n          setCutLength([nextStartLen, nextMidLen, nextEndLen]);\n        } else {\n          setWalkingState(DONE_WITH_ELLIPSIS);\n          setLastLen(midLen);\n          onEllipsis(true);\n        }\n      }\n    }\n  }, [walkingState, startLen, endLen, rows, singleRowHeight]); // ======================= Render =======================\n\n  const measureStyle = {\n    width,\n    whiteSpace: 'normal',\n    margin: 0,\n    padding: 0\n  };\n\n  const renderMeasure = (content, ref, style) => /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-hidden\": true,\n    ref: ref,\n    style: Object.assign({\n      position: 'fixed',\n      display: 'block',\n      left: 0,\n      top: 0,\n      zIndex: -9999,\n      visibility: 'hidden',\n      pointerEvents: 'none',\n      fontSize: Math.floor(fontSize / 2) * 2\n    }, style)\n  }, content);\n\n  const renderMeasureSlice = (len, ref) => {\n    const sliceNodeList = sliceNodes(nodeList, len);\n    return renderMeasure(children(sliceNodeList, true), ref, measureStyle);\n  };\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, mergedChildren, enabledMeasure && walkingState !== DONE_WITH_ELLIPSIS && walkingState !== DONE_WITHOUT_ELLIPSIS && /*#__PURE__*/React.createElement(React.Fragment, null, renderMeasure('lg', singleRowRef, {\n    wordBreak: 'keep-all',\n    whiteSpace: 'nowrap'\n  }), walkingState === PREPARE ? renderMeasure(children(nodeList, false), midRowRef, measureStyle) : renderMeasureSlice(midLen, midRowRef)));\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  Ellipsis.displayName = 'Ellipsis';\n}\n\nexport default Ellipsis;","map":{"version":3,"sources":["/Users/ravisrivastava/Downloads/newbcom/node_modules/antd/es/typography/Base/Ellipsis.js"],"names":["toArray","useIsomorphicLayoutEffect","React","cuttable","node","type","getNodesLen","nodeList","totalLen","forEach","String","length","sliceNodes","len","currLen","currentNodeList","i","canCut","nodeLen","nextLen","restLen","push","slice","NONE","PREPARE","WALKING","DONE_WITH_ELLIPSIS","DONE_WITHOUT_ELLIPSIS","Ellipsis","_ref","enabledMeasure","children","text","width","fontSize","rows","onEllipsis","startLen","midLen","endLen","setCutLength","useState","lastLen","setLastLen","walkingState","setWalkingState","singleRowHeight","setSingleRowHeight","singleRowRef","useRef","midRowRef","useMemo","mergedChildren","Math","ceil","_a","current","offsetHeight","_b","midHeight","maxHeight","nextStartLen","nextEndLen","nextMidLen","measureStyle","whiteSpace","margin","padding","renderMeasure","content","ref","style","createElement","Object","assign","position","display","left","top","zIndex","visibility","pointerEvents","floor","renderMeasureSlice","sliceNodeList","Fragment","wordBreak","process","env","NODE_ENV","displayName"],"mappings":"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","sourcesContent":["\"use client\";\n\nimport toArray from \"rc-util/es/Children/toArray\";\nimport useIsomorphicLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nfunction cuttable(node) {\n  const type = typeof node;\n  return type === 'string' || type === 'number';\n}\nfunction getNodesLen(nodeList) {\n  let totalLen = 0;\n  nodeList.forEach(node => {\n    if (cuttable(node)) {\n      totalLen += String(node).length;\n    } else {\n      totalLen += 1;\n    }\n  });\n  return totalLen;\n}\nfunction sliceNodes(nodeList, len) {\n  let currLen = 0;\n  const currentNodeList = [];\n  for (let i = 0; i < nodeList.length; i += 1) {\n    // Match to return\n    if (currLen === len) {\n      return currentNodeList;\n    }\n    const node = nodeList[i];\n    const canCut = cuttable(node);\n    const nodeLen = canCut ? String(node).length : 1;\n    const nextLen = currLen + nodeLen;\n    // Exceed but current not which means we need cut this\n    // This will not happen on validate ReactElement\n    if (nextLen > len) {\n      const restLen = len - currLen;\n      currentNodeList.push(String(node).slice(0, restLen));\n      return currentNodeList;\n    }\n    currentNodeList.push(node);\n    currLen = nextLen;\n  }\n  return nodeList;\n}\nconst NONE = 0;\nconst PREPARE = 1;\nconst WALKING = 2;\nconst DONE_WITH_ELLIPSIS = 3;\nconst DONE_WITHOUT_ELLIPSIS = 4;\nconst Ellipsis = _ref => {\n  let {\n    enabledMeasure,\n    children,\n    text,\n    width,\n    fontSize,\n    rows,\n    onEllipsis\n  } = _ref;\n  const [[startLen, midLen, endLen], setCutLength] = React.useState([0, 0, 0]);\n  // record last done with ellipsis width\n  const [lastLen, setLastLen] = React.useState(0);\n  const [walkingState, setWalkingState] = React.useState(NONE);\n  const [singleRowHeight, setSingleRowHeight] = React.useState(0);\n  const singleRowRef = React.useRef(null);\n  const midRowRef = React.useRef(null);\n  const nodeList = React.useMemo(() => toArray(text), [text]);\n  const totalLen = React.useMemo(() => getNodesLen(nodeList), [nodeList]);\n  const mergedChildren = React.useMemo(() => {\n    if (!enabledMeasure || walkingState !== DONE_WITH_ELLIPSIS) {\n      // if has lastLen, use it as temporary width to avoid lots of text to squeeze space.\n      if (lastLen && walkingState !== DONE_WITHOUT_ELLIPSIS && enabledMeasure) return children(sliceNodes(nodeList, lastLen), lastLen < totalLen);\n      return children(nodeList, false);\n    }\n    return children(sliceNodes(nodeList, midLen), midLen < totalLen);\n  }, [enabledMeasure, walkingState, children, nodeList, midLen, totalLen]);\n  // ======================== Walk ========================\n  useIsomorphicLayoutEffect(() => {\n    if (enabledMeasure && width && fontSize && totalLen) {\n      setWalkingState(PREPARE);\n      setCutLength([0, Math.ceil(totalLen / 2), totalLen]);\n    }\n  }, [enabledMeasure, width, fontSize, text, totalLen, rows]);\n  useIsomorphicLayoutEffect(() => {\n    var _a;\n    if (walkingState === PREPARE) {\n      setSingleRowHeight(((_a = singleRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0);\n    }\n  }, [walkingState]);\n  useIsomorphicLayoutEffect(() => {\n    var _a, _b;\n    if (singleRowHeight) {\n      if (walkingState === PREPARE) {\n        // Ignore if position is enough\n        const midHeight = ((_a = midRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;\n        const maxHeight = rows * singleRowHeight;\n        if (midHeight <= maxHeight) {\n          setWalkingState(DONE_WITHOUT_ELLIPSIS);\n          onEllipsis(false);\n        } else {\n          setWalkingState(WALKING);\n        }\n      } else if (walkingState === WALKING) {\n        if (startLen !== endLen) {\n          const midHeight = ((_b = midRowRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;\n          const maxHeight = rows * singleRowHeight;\n          let nextStartLen = startLen;\n          let nextEndLen = endLen;\n          // We reach the last round\n          if (startLen === endLen - 1) {\n            nextEndLen = startLen;\n          } else if (midHeight <= maxHeight) {\n            nextStartLen = midLen;\n          } else {\n            nextEndLen = midLen;\n          }\n          const nextMidLen = Math.ceil((nextStartLen + nextEndLen) / 2);\n          setCutLength([nextStartLen, nextMidLen, nextEndLen]);\n        } else {\n          setWalkingState(DONE_WITH_ELLIPSIS);\n          setLastLen(midLen);\n          onEllipsis(true);\n        }\n      }\n    }\n  }, [walkingState, startLen, endLen, rows, singleRowHeight]);\n  // ======================= Render =======================\n  const measureStyle = {\n    width,\n    whiteSpace: 'normal',\n    margin: 0,\n    padding: 0\n  };\n  const renderMeasure = (content, ref, style) => /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-hidden\": true,\n    ref: ref,\n    style: Object.assign({\n      position: 'fixed',\n      display: 'block',\n      left: 0,\n      top: 0,\n      zIndex: -9999,\n      visibility: 'hidden',\n      pointerEvents: 'none',\n      fontSize: Math.floor(fontSize / 2) * 2\n    }, style)\n  }, content);\n  const renderMeasureSlice = (len, ref) => {\n    const sliceNodeList = sliceNodes(nodeList, len);\n    return renderMeasure(children(sliceNodeList, true), ref, measureStyle);\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, mergedChildren, enabledMeasure && walkingState !== DONE_WITH_ELLIPSIS && walkingState !== DONE_WITHOUT_ELLIPSIS && /*#__PURE__*/React.createElement(React.Fragment, null, renderMeasure('lg', singleRowRef, {\n    wordBreak: 'keep-all',\n    whiteSpace: 'nowrap'\n  }), walkingState === PREPARE ? renderMeasure(children(nodeList, false), midRowRef, measureStyle) : renderMeasureSlice(midLen, midRowRef)));\n};\nif (process.env.NODE_ENV !== 'production') {\n  Ellipsis.displayName = 'Ellipsis';\n}\nexport default Ellipsis;"]},"metadata":{},"sourceType":"module"}