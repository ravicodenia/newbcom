{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { getFocusNodeList } from \"rc-util/es/Dom/focus\";\nimport KeyCode from \"rc-util/es/KeyCode\";\nimport raf from \"rc-util/es/raf\";\nimport * as React from 'react';\nimport { getMenuId } from \"../context/IdContext\"; // destruct to reduce minify size\n\nvar LEFT = KeyCode.LEFT,\n    RIGHT = KeyCode.RIGHT,\n    UP = KeyCode.UP,\n    DOWN = KeyCode.DOWN,\n    ENTER = KeyCode.ENTER,\n    ESC = KeyCode.ESC,\n    HOME = KeyCode.HOME,\n    END = KeyCode.END;\nvar ArrowKeys = [UP, DOWN, LEFT, RIGHT];\n\nfunction getOffset(mode, isRootLevel, isRtl, which) {\n  var _inline, _horizontal, _vertical, _offsets;\n\n  var prev = 'prev';\n  var next = 'next';\n  var children = 'children';\n  var parent = 'parent'; // Inline enter is special that we use unique operation\n\n  if (mode === 'inline' && which === ENTER) {\n    return {\n      inlineTrigger: true\n    };\n  }\n\n  var inline = (_inline = {}, _defineProperty(_inline, UP, prev), _defineProperty(_inline, DOWN, next), _inline);\n  var horizontal = (_horizontal = {}, _defineProperty(_horizontal, LEFT, isRtl ? next : prev), _defineProperty(_horizontal, RIGHT, isRtl ? prev : next), _defineProperty(_horizontal, DOWN, children), _defineProperty(_horizontal, ENTER, children), _horizontal);\n  var vertical = (_vertical = {}, _defineProperty(_vertical, UP, prev), _defineProperty(_vertical, DOWN, next), _defineProperty(_vertical, ENTER, children), _defineProperty(_vertical, ESC, parent), _defineProperty(_vertical, LEFT, isRtl ? children : parent), _defineProperty(_vertical, RIGHT, isRtl ? parent : children), _vertical);\n  var offsets = {\n    inline: inline,\n    horizontal: horizontal,\n    vertical: vertical,\n    inlineSub: inline,\n    horizontalSub: vertical,\n    verticalSub: vertical\n  };\n  var type = (_offsets = offsets[\"\".concat(mode).concat(isRootLevel ? '' : 'Sub')]) === null || _offsets === void 0 ? void 0 : _offsets[which];\n\n  switch (type) {\n    case prev:\n      return {\n        offset: -1,\n        sibling: true\n      };\n\n    case next:\n      return {\n        offset: 1,\n        sibling: true\n      };\n\n    case parent:\n      return {\n        offset: -1,\n        sibling: false\n      };\n\n    case children:\n      return {\n        offset: 1,\n        sibling: false\n      };\n\n    default:\n      return null;\n  }\n}\n\nfunction findContainerUL(element) {\n  var current = element;\n\n  while (current) {\n    if (current.getAttribute('data-menu-list')) {\n      return current;\n    }\n\n    current = current.parentElement;\n  } // Normally should not reach this line\n\n  /* istanbul ignore next */\n\n\n  return null;\n}\n/**\n * Find focused element within element set provided\n */\n\n\nfunction getFocusElement(activeElement, elements) {\n  var current = activeElement || document.activeElement;\n\n  while (current) {\n    if (elements.has(current)) {\n      return current;\n    }\n\n    current = current.parentElement;\n  }\n\n  return null;\n}\n/**\n * Get focusable elements from the element set under provided container\n */\n\n\nexport function getFocusableElements(container, elements) {\n  var list = getFocusNodeList(container, true);\n  return list.filter(function (ele) {\n    return elements.has(ele);\n  });\n}\n\nfunction getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {\n  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1; // Key on the menu item will not get validate parent container\n\n  if (!parentQueryContainer) {\n    return null;\n  } // List current level menu item elements\n\n\n  var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements); // Find next focus index\n\n  var count = sameLevelFocusableMenuElementList.length;\n  var focusIndex = sameLevelFocusableMenuElementList.findIndex(function (ele) {\n    return focusMenuElement === ele;\n  });\n\n  if (offset < 0) {\n    if (focusIndex === -1) {\n      focusIndex = count - 1;\n    } else {\n      focusIndex -= 1;\n    }\n  } else if (offset > 0) {\n    focusIndex += 1;\n  }\n\n  focusIndex = (focusIndex + count) % count; // Focus menu item\n\n  return sameLevelFocusableMenuElementList[focusIndex];\n}\n\nexport var refreshElements = function refreshElements(keys, id) {\n  var elements = new Set();\n  var key2element = new Map();\n  var element2key = new Map();\n  keys.forEach(function (key) {\n    var element = document.querySelector(\"[data-menu-id='\".concat(getMenuId(id, key), \"']\"));\n\n    if (element) {\n      elements.add(element);\n      element2key.set(element, key);\n      key2element.set(key, element);\n    }\n  });\n  return {\n    elements: elements,\n    key2element: key2element,\n    element2key: element2key\n  };\n};\nexport function useAccessibility(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {\n  var rafRef = React.useRef();\n  var activeRef = React.useRef();\n  activeRef.current = activeKey;\n\n  var cleanRaf = function cleanRaf() {\n    raf.cancel(rafRef.current);\n  };\n\n  React.useEffect(function () {\n    return function () {\n      cleanRaf();\n    };\n  }, []);\n  return function (e) {\n    var which = e.which;\n\n    if ([].concat(ArrowKeys, [ENTER, ESC, HOME, END]).includes(which)) {\n      var keys = getKeys();\n      var refreshedElements = refreshElements(keys, id);\n      var _refreshedElements = refreshedElements,\n          elements = _refreshedElements.elements,\n          key2element = _refreshedElements.key2element,\n          element2key = _refreshedElements.element2key; // First we should find current focused MenuItem/SubMenu element\n\n      var activeElement = key2element.get(activeKey);\n      var focusMenuElement = getFocusElement(activeElement, elements);\n      var focusMenuKey = element2key.get(focusMenuElement);\n      var offsetObj = getOffset(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which); // Some mode do not have fully arrow operation like inline\n\n      if (!offsetObj && which !== HOME && which !== END) {\n        return;\n      } // Arrow prevent default to avoid page scroll\n\n\n      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {\n        e.preventDefault();\n      }\n\n      var tryFocus = function tryFocus(menuElement) {\n        if (menuElement) {\n          var focusTargetElement = menuElement; // Focus to link instead of menu item if possible\n\n          var link = menuElement.querySelector('a');\n\n          if (link !== null && link !== void 0 && link.getAttribute('href')) {\n            focusTargetElement = link;\n          }\n\n          var targetKey = element2key.get(menuElement);\n          triggerActiveKey(targetKey);\n          /**\n           * Do not `useEffect` here since `tryFocus` may trigger async\n           * which makes React sync update the `activeKey`\n           * that force render before `useRef` set the next activeKey\n           */\n\n          cleanRaf();\n          rafRef.current = raf(function () {\n            if (activeRef.current === targetKey) {\n              focusTargetElement.focus();\n            }\n          });\n        }\n      };\n\n      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {\n        // ========================== Sibling ==========================\n        // Find walkable focus menu element container\n        var parentQueryContainer;\n\n        if (!focusMenuElement || mode === 'inline') {\n          parentQueryContainer = containerRef.current;\n        } else {\n          parentQueryContainer = findContainerUL(focusMenuElement);\n        } // Get next focus element\n\n\n        var targetElement;\n        var focusableElements = getFocusableElements(parentQueryContainer, elements);\n\n        if (which === HOME) {\n          targetElement = focusableElements[0];\n        } else if (which === END) {\n          targetElement = focusableElements[focusableElements.length - 1];\n        } else {\n          targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);\n        } // Focus menu item\n\n\n        tryFocus(targetElement); // ======================= InlineTrigger =======================\n      } else if (offsetObj.inlineTrigger) {\n        // Inline trigger no need switch to sub menu item\n        triggerAccessibilityOpen(focusMenuKey); // =========================== Level ===========================\n      } else if (offsetObj.offset > 0) {\n        triggerAccessibilityOpen(focusMenuKey, true);\n        cleanRaf();\n        rafRef.current = raf(function () {\n          // Async should resync elements\n          refreshedElements = refreshElements(keys, id);\n          var controlId = focusMenuElement.getAttribute('aria-controls');\n          var subQueryContainer = document.getElementById(controlId); // Get sub focusable menu item\n\n          var targetElement = getNextFocusElement(subQueryContainer, refreshedElements.elements); // Focus menu item\n\n          tryFocus(targetElement);\n        }, 5);\n      } else if (offsetObj.offset < 0) {\n        var keyPath = getKeyPath(focusMenuKey, true);\n        var parentKey = keyPath[keyPath.length - 2];\n        var parentMenuElement = key2element.get(parentKey); // Focus menu item\n\n        triggerAccessibilityOpen(parentKey, false);\n        tryFocus(parentMenuElement);\n      }\n    } // Pass origin key down event\n\n\n    originOnKeyDown === null || originOnKeyDown === void 0 || originOnKeyDown(e);\n  };\n}","map":{"version":3,"sources":["/Users/ravisrivastava/Downloads/newbcom2/newbcom/node_modules/rc-menu/es/hooks/useAccessibility.js"],"names":["_defineProperty","getFocusNodeList","KeyCode","raf","React","getMenuId","LEFT","RIGHT","UP","DOWN","ENTER","ESC","HOME","END","ArrowKeys","getOffset","mode","isRootLevel","isRtl","which","_inline","_horizontal","_vertical","_offsets","prev","next","children","parent","inlineTrigger","inline","horizontal","vertical","offsets","inlineSub","horizontalSub","verticalSub","type","concat","offset","sibling","findContainerUL","element","current","getAttribute","parentElement","getFocusElement","activeElement","elements","document","has","getFocusableElements","container","list","filter","ele","getNextFocusElement","parentQueryContainer","focusMenuElement","arguments","length","undefined","sameLevelFocusableMenuElementList","count","focusIndex","findIndex","refreshElements","keys","id","Set","key2element","Map","element2key","forEach","key","querySelector","add","set","useAccessibility","activeKey","containerRef","getKeys","getKeyPath","triggerActiveKey","triggerAccessibilityOpen","originOnKeyDown","rafRef","useRef","activeRef","cleanRaf","cancel","useEffect","e","includes","refreshedElements","_refreshedElements","get","focusMenuKey","offsetObj","preventDefault","tryFocus","menuElement","focusTargetElement","link","targetKey","focus","targetElement","focusableElements","controlId","subQueryContainer","getElementById","keyPath","parentKey","parentMenuElement"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { getFocusNodeList } from \"rc-util/es/Dom/focus\";\nimport KeyCode from \"rc-util/es/KeyCode\";\nimport raf from \"rc-util/es/raf\";\nimport * as React from 'react';\nimport { getMenuId } from \"../context/IdContext\";\n// destruct to reduce minify size\nvar LEFT = KeyCode.LEFT,\n  RIGHT = KeyCode.RIGHT,\n  UP = KeyCode.UP,\n  DOWN = KeyCode.DOWN,\n  ENTER = KeyCode.ENTER,\n  ESC = KeyCode.ESC,\n  HOME = KeyCode.HOME,\n  END = KeyCode.END;\nvar ArrowKeys = [UP, DOWN, LEFT, RIGHT];\nfunction getOffset(mode, isRootLevel, isRtl, which) {\n  var _inline, _horizontal, _vertical, _offsets;\n  var prev = 'prev';\n  var next = 'next';\n  var children = 'children';\n  var parent = 'parent';\n\n  // Inline enter is special that we use unique operation\n  if (mode === 'inline' && which === ENTER) {\n    return {\n      inlineTrigger: true\n    };\n  }\n  var inline = (_inline = {}, _defineProperty(_inline, UP, prev), _defineProperty(_inline, DOWN, next), _inline);\n  var horizontal = (_horizontal = {}, _defineProperty(_horizontal, LEFT, isRtl ? next : prev), _defineProperty(_horizontal, RIGHT, isRtl ? prev : next), _defineProperty(_horizontal, DOWN, children), _defineProperty(_horizontal, ENTER, children), _horizontal);\n  var vertical = (_vertical = {}, _defineProperty(_vertical, UP, prev), _defineProperty(_vertical, DOWN, next), _defineProperty(_vertical, ENTER, children), _defineProperty(_vertical, ESC, parent), _defineProperty(_vertical, LEFT, isRtl ? children : parent), _defineProperty(_vertical, RIGHT, isRtl ? parent : children), _vertical);\n  var offsets = {\n    inline: inline,\n    horizontal: horizontal,\n    vertical: vertical,\n    inlineSub: inline,\n    horizontalSub: vertical,\n    verticalSub: vertical\n  };\n  var type = (_offsets = offsets[\"\".concat(mode).concat(isRootLevel ? '' : 'Sub')]) === null || _offsets === void 0 ? void 0 : _offsets[which];\n  switch (type) {\n    case prev:\n      return {\n        offset: -1,\n        sibling: true\n      };\n    case next:\n      return {\n        offset: 1,\n        sibling: true\n      };\n    case parent:\n      return {\n        offset: -1,\n        sibling: false\n      };\n    case children:\n      return {\n        offset: 1,\n        sibling: false\n      };\n    default:\n      return null;\n  }\n}\nfunction findContainerUL(element) {\n  var current = element;\n  while (current) {\n    if (current.getAttribute('data-menu-list')) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n\n  // Normally should not reach this line\n  /* istanbul ignore next */\n  return null;\n}\n\n/**\n * Find focused element within element set provided\n */\nfunction getFocusElement(activeElement, elements) {\n  var current = activeElement || document.activeElement;\n  while (current) {\n    if (elements.has(current)) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n  return null;\n}\n\n/**\n * Get focusable elements from the element set under provided container\n */\nexport function getFocusableElements(container, elements) {\n  var list = getFocusNodeList(container, true);\n  return list.filter(function (ele) {\n    return elements.has(ele);\n  });\n}\nfunction getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {\n  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  // Key on the menu item will not get validate parent container\n  if (!parentQueryContainer) {\n    return null;\n  }\n\n  // List current level menu item elements\n  var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);\n\n  // Find next focus index\n  var count = sameLevelFocusableMenuElementList.length;\n  var focusIndex = sameLevelFocusableMenuElementList.findIndex(function (ele) {\n    return focusMenuElement === ele;\n  });\n  if (offset < 0) {\n    if (focusIndex === -1) {\n      focusIndex = count - 1;\n    } else {\n      focusIndex -= 1;\n    }\n  } else if (offset > 0) {\n    focusIndex += 1;\n  }\n  focusIndex = (focusIndex + count) % count;\n\n  // Focus menu item\n  return sameLevelFocusableMenuElementList[focusIndex];\n}\nexport var refreshElements = function refreshElements(keys, id) {\n  var elements = new Set();\n  var key2element = new Map();\n  var element2key = new Map();\n  keys.forEach(function (key) {\n    var element = document.querySelector(\"[data-menu-id='\".concat(getMenuId(id, key), \"']\"));\n    if (element) {\n      elements.add(element);\n      element2key.set(element, key);\n      key2element.set(key, element);\n    }\n  });\n  return {\n    elements: elements,\n    key2element: key2element,\n    element2key: element2key\n  };\n};\nexport function useAccessibility(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {\n  var rafRef = React.useRef();\n  var activeRef = React.useRef();\n  activeRef.current = activeKey;\n  var cleanRaf = function cleanRaf() {\n    raf.cancel(rafRef.current);\n  };\n  React.useEffect(function () {\n    return function () {\n      cleanRaf();\n    };\n  }, []);\n  return function (e) {\n    var which = e.which;\n    if ([].concat(ArrowKeys, [ENTER, ESC, HOME, END]).includes(which)) {\n      var keys = getKeys();\n      var refreshedElements = refreshElements(keys, id);\n      var _refreshedElements = refreshedElements,\n        elements = _refreshedElements.elements,\n        key2element = _refreshedElements.key2element,\n        element2key = _refreshedElements.element2key;\n\n      // First we should find current focused MenuItem/SubMenu element\n      var activeElement = key2element.get(activeKey);\n      var focusMenuElement = getFocusElement(activeElement, elements);\n      var focusMenuKey = element2key.get(focusMenuElement);\n      var offsetObj = getOffset(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);\n\n      // Some mode do not have fully arrow operation like inline\n      if (!offsetObj && which !== HOME && which !== END) {\n        return;\n      }\n\n      // Arrow prevent default to avoid page scroll\n      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {\n        e.preventDefault();\n      }\n      var tryFocus = function tryFocus(menuElement) {\n        if (menuElement) {\n          var focusTargetElement = menuElement;\n\n          // Focus to link instead of menu item if possible\n          var link = menuElement.querySelector('a');\n          if (link !== null && link !== void 0 && link.getAttribute('href')) {\n            focusTargetElement = link;\n          }\n          var targetKey = element2key.get(menuElement);\n          triggerActiveKey(targetKey);\n\n          /**\n           * Do not `useEffect` here since `tryFocus` may trigger async\n           * which makes React sync update the `activeKey`\n           * that force render before `useRef` set the next activeKey\n           */\n          cleanRaf();\n          rafRef.current = raf(function () {\n            if (activeRef.current === targetKey) {\n              focusTargetElement.focus();\n            }\n          });\n        }\n      };\n      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {\n        // ========================== Sibling ==========================\n        // Find walkable focus menu element container\n        var parentQueryContainer;\n        if (!focusMenuElement || mode === 'inline') {\n          parentQueryContainer = containerRef.current;\n        } else {\n          parentQueryContainer = findContainerUL(focusMenuElement);\n        }\n\n        // Get next focus element\n        var targetElement;\n        var focusableElements = getFocusableElements(parentQueryContainer, elements);\n        if (which === HOME) {\n          targetElement = focusableElements[0];\n        } else if (which === END) {\n          targetElement = focusableElements[focusableElements.length - 1];\n        } else {\n          targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);\n        }\n        // Focus menu item\n        tryFocus(targetElement);\n\n        // ======================= InlineTrigger =======================\n      } else if (offsetObj.inlineTrigger) {\n        // Inline trigger no need switch to sub menu item\n        triggerAccessibilityOpen(focusMenuKey);\n        // =========================== Level ===========================\n      } else if (offsetObj.offset > 0) {\n        triggerAccessibilityOpen(focusMenuKey, true);\n        cleanRaf();\n        rafRef.current = raf(function () {\n          // Async should resync elements\n          refreshedElements = refreshElements(keys, id);\n          var controlId = focusMenuElement.getAttribute('aria-controls');\n          var subQueryContainer = document.getElementById(controlId);\n\n          // Get sub focusable menu item\n          var targetElement = getNextFocusElement(subQueryContainer, refreshedElements.elements);\n\n          // Focus menu item\n          tryFocus(targetElement);\n        }, 5);\n      } else if (offsetObj.offset < 0) {\n        var keyPath = getKeyPath(focusMenuKey, true);\n        var parentKey = keyPath[keyPath.length - 2];\n        var parentMenuElement = key2element.get(parentKey);\n\n        // Focus menu item\n        triggerAccessibilityOpen(parentKey, false);\n        tryFocus(parentMenuElement);\n      }\n    }\n\n    // Pass origin key down event\n    originOnKeyDown === null || originOnKeyDown === void 0 || originOnKeyDown(e);\n  };\n}"]},"metadata":{},"sourceType":"module"}