{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport { isValidElement } from 'react';\nimport { ForwardRef, isFragment, isMemo } from 'react-is';\nimport useMemo from \"./hooks/useMemo\";\nexport var fillRef = function fillRef(ref, node) {\n  if (typeof ref === 'function') {\n    ref(node);\n  } else if (_typeof(ref) === 'object' && ref && 'current' in ref) {\n    ref.current = node;\n  }\n};\n/**\n * Merge refs into one ref function to support ref passing.\n */\n\nexport var composeRef = function composeRef() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  var refList = refs.filter(Boolean);\n\n  if (refList.length <= 1) {\n    return refList[0];\n  }\n\n  return function (node) {\n    refs.forEach(function (ref) {\n      fillRef(ref, node);\n    });\n  };\n};\nexport var useComposeRef = function useComposeRef() {\n  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    refs[_key2] = arguments[_key2];\n  }\n\n  return useMemo(function () {\n    return composeRef.apply(void 0, refs);\n  }, refs, function (prev, next) {\n    return prev.length !== next.length || prev.every(function (ref, i) {\n      return ref !== next[i];\n    });\n  });\n};\nexport var supportRef = function supportRef(nodeOrComponent) {\n  var _type$prototype, _nodeOrComponent$prot;\n\n  var type = isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type; // Function component node\n\n  if (typeof type === 'function' && !((_type$prototype = type.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render) && type.$$typeof !== ForwardRef) {\n    return false;\n  } // Class component\n\n\n  if (typeof nodeOrComponent === 'function' && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render) && nodeOrComponent.$$typeof !== ForwardRef) {\n    return false;\n  }\n\n  return true;\n};\nexport var supportNodeRef = function supportNodeRef(node) {\n  if (! /*#__PURE__*/isValidElement(node)) {\n    return false;\n  }\n\n  if (isFragment(node)) {\n    return false;\n  }\n\n  return supportRef(node);\n};","map":{"version":3,"sources":["/Users/ravisrivastava/Downloads/newbcom2/newbcom/node_modules/rc-util/es/ref.js"],"names":["_typeof","isValidElement","ForwardRef","isFragment","isMemo","useMemo","fillRef","ref","node","current","composeRef","_len","arguments","length","refs","Array","_key","refList","filter","Boolean","forEach","useComposeRef","_len2","_key2","apply","prev","next","every","i","supportRef","nodeOrComponent","_type$prototype","_nodeOrComponent$prot","type","prototype","render","$$typeof","supportNodeRef"],"mappings":"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","sourcesContent":["import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport { isValidElement } from 'react';\nimport { ForwardRef, isFragment, isMemo } from 'react-is';\nimport useMemo from \"./hooks/useMemo\";\nexport var fillRef = function fillRef(ref, node) {\n  if (typeof ref === 'function') {\n    ref(node);\n  } else if (_typeof(ref) === 'object' && ref && 'current' in ref) {\n    ref.current = node;\n  }\n};\n\n/**\n * Merge refs into one ref function to support ref passing.\n */\nexport var composeRef = function composeRef() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n  var refList = refs.filter(Boolean);\n  if (refList.length <= 1) {\n    return refList[0];\n  }\n  return function (node) {\n    refs.forEach(function (ref) {\n      fillRef(ref, node);\n    });\n  };\n};\nexport var useComposeRef = function useComposeRef() {\n  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    refs[_key2] = arguments[_key2];\n  }\n  return useMemo(function () {\n    return composeRef.apply(void 0, refs);\n  }, refs, function (prev, next) {\n    return prev.length !== next.length || prev.every(function (ref, i) {\n      return ref !== next[i];\n    });\n  });\n};\nexport var supportRef = function supportRef(nodeOrComponent) {\n  var _type$prototype, _nodeOrComponent$prot;\n  var type = isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;\n\n  // Function component node\n  if (typeof type === 'function' && !((_type$prototype = type.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render) && type.$$typeof !== ForwardRef) {\n    return false;\n  }\n\n  // Class component\n  if (typeof nodeOrComponent === 'function' && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render) && nodeOrComponent.$$typeof !== ForwardRef) {\n    return false;\n  }\n  return true;\n};\nexport var supportNodeRef = function supportNodeRef(node) {\n  if (! /*#__PURE__*/isValidElement(node)) {\n    return false;\n  }\n  if (isFragment(node)) {\n    return false;\n  }\n  return supportRef(node);\n};"]},"metadata":{},"sourceType":"module"}